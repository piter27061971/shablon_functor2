// ConsoleApplication36.cpp : Этот файл содержит функцию "main". Здесь начинается и заканчивается выполнение программы.
//

#include <iostream>
template<class T>

class  table
{
private:
    class submasT;// подкласс строк матрицы (объявление)
    int row, col; // количества строк и колонок матрицы
    submasT* arrT; // указатель на массив подкласса строк матрицы
    class submasT// подкласс строк матрицы (реализация)
    {
    public:
        T* sarrT;
        // конструктор по умолчанию необходим для создания массива указателей на класс подстрок матрицы
        
        submasT() {}
        submasT(int size)
        {
            sarrT = new T[size]; // создание массива данных типа T
           
        }
        T& operator [] (int i) // оператор [] возвращает ссылку на T
        {
            return sarrT[i];
        }
        const T& operator [] (int i) const // оператор [] возвращает ссылку на T
        {
            return sarrT[i];
        }
        // деструктор не нужен, если если его поставить, то строки матрицы будут 
        // удаляться до того, как заполнится вся матрица
        //      ~submasT()   
        //{
        //  if (sarrT != nullptr) delete[] sarrT;
        //}
    };

public:
    table(const int rows, const int cols) //класс матрица целых чисел
    {
        rows < 1 ? row = 1 : row = rows; // защита от ввода количества строк или столбцов менее 1
        cols < 1 ? col = 1 : col = cols;
        // создание массива указателей с использованием конструктора по умолчанию (без параметров)
        arrT = new submasT[row];
        for (int i = 0; i < row; i++)
        {
            // создания строк матрицы. если у подкласса строк матрицы будет деструктор,
            // то строки будут удаляться в каждей итерации цикла
            arrT[i] = submasT(col);
        }
    }
    submasT& operator [] (int i)// оператор [] возвращает ссылку на подкласс строк матрицы
    {
        return arrT[i];
    }
    const submasT& operator [] (int i) const// оператор [] возвращает ссылку на подкласс строк матрицы
    {
        return arrT[i];
    }

    int GetCol() // метод получения количества колонок матрицы
    {
        return col;
    }
    int GetRow()// метод получения количества строк матрицы
    {
        return row;
    }
    int Size() // метод получения количество элементов в матрице
    {
        return (col * row);
    }
    ~table()
    {
        for (int i = 0; i < row; i++)
        {// удаление строк матрицы
            if (arrT[i].sarrT != nullptr)
                delete[](arrT[i].sarrT);
        }
        if (arrT != nullptr)
            delete[] arrT;// удаление массива указателей на строки матрицы
    }
};

int main()
{
    setlocale(LC_ALL, "Russian");
    auto test = table<double>(2, 3);
    test[0][0] = 4.5;
    std::cout << test[0][0] << std::endl;
    std::cout << test.Size()<<std::endl;
}


// Запуск программы: CTRL+F5 или меню "Отладка" > "Запуск без отладки"
// Отладка программы: F5 или меню "Отладка" > "Запустить отладку"

// Советы по началу работы 
//   1. В окне обозревателя решений можно добавлять файлы и управлять ими.
//   2. В окне Team Explorer можно подключиться к системе управления версиями.
//   3. В окне "Выходные данные" можно просматривать выходные данные сборки и другие сообщения.
//   4. В окне "Список ошибок" можно просматривать ошибки.
//   5. Последовательно выберите пункты меню "Проект" > "Добавить новый элемент", чтобы создать файлы кода, или "Проект" > "Добавить существующий элемент", чтобы добавить в проект существующие файлы кода.
//   6. Чтобы снова открыть этот проект позже, выберите пункты меню "Файл" > "Открыть" > "Проект" и выберите SLN-файл.
